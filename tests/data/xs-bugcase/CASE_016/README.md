# CASE_016: inner_ftq io_fromBpu_prediction_ready divergence

## Problem Description

The `inner_ftq` module generates `io_fromBpu_prediction_ready` signal incorrectly in wolf-sv-parser compared to reference.

### Divergence Details

| Signal | Ref (t=1154) | Wolf (t=1154) |
|--------|--------------|---------------|
| `io_fromBpu_prediction_ready` | 0 | 1 (unchanged from init) |

- In wolf waveform, this signal has **no events** in t=[1100, 1200], maintaining initial value of 1
- In ref waveform, it transitions to 0 at t=1154

### Impact

This divergence propagates through the BPU pipeline:
```
inner_ftq.io_fromBpu_prediction_ready (diverges at t=1154)
  → inner_bpu.io_toFtq_prediction_ready
    → inner_bpu.s1_fire
      → [629 signals diverge simultaneously in inner_bpu]
```

## DUT

- **Module:** `Ftq` (inner_ftq)
- **File:** `rtl/Ftq.sv` (148,441 lines)
- **Sub-modules:** `ResolveQueue`, `CommitQueue`

## Trace Replay

Testbench implements simplified trace replay based on extracted waveform events:

| Cycle | Event (Reference) |
|-------|-------------------|
| 3 | `io_fromBpu_prediction_valid = 1` (was t=1132) |
| 4 | `io_fromBpu_meta_valid = 1` (was t=1136) |
| 5-7 | **Divergence window** - `io_fromBpu_prediction_ready` expected to diverge |
| 8 | `io_fromBpu_meta_valid = 0` (was t=1158) |

### Full Event Data

See `events.json` for extracted waveform events.

## Quick Start

```bash
cd tests/data/xs-bugcase/CASE_016
make          # Full build and test (~3 minutes)
```

## Building and Running

```bash
cd tests/data/xs-bugcase/CASE_016

# One-step build and run
make run

# Quick test (skip rebuild if binary exists)
make quick

# Individual steps
make build_ref    # Build reference (original RTL)
make build_wolf   # Build wolf (wolf-sv-parser processed)
make run          # Run comparison test

# Direct binary execution
/workspace/wolf-sv-parser/build/xs_bugcase/CASE_016/sim_CASE_016
```

### Make Targets

| Target | Description |
|--------|-------------|
| `make` / `make all` | Full build and test (default) |
| `make run` | Build and run test |
| `make quick` | Run test without rebuilding (~1 sec) |
| `make build_ref` | Build reference version only |
| `make build_wolf` | Build wolf version only |
| `make clean` | Remove all build artifacts |
| `make help` | Show help message |

## Status

- ✅ DUT RTL extracted
- ✅ Testbench with trace replay
- ✅ Event data extracted
- ✅ **Bug reproduced!**

### Test Result

```
$ ./sim_CASE_016
[MISMATCH] cycle=20 io_fromBpu_prediction_ready ref=0 wolf=1
```

**Divergence confirmed** - matches original waveform behavior:
- Original: t=1154, ref=0, wolf=1
- Bug case: cycle=20, ref=0, wolf=1

## Why CASE_014 Couldn't Reproduce

CASE_014 tested `inner_bpu` in isolation. The divergence originates in `inner_ftq`, upstream of BPU. Even a correctly-implemented `inner_bpu` will show divergence when driven by incorrect FTQ inputs.

## Root Cause Analysis

The `io_fromBpu_prediction_ready` signal is generated by complex logic in Ftq.sv:

```verilog
wire io_fromBpu_prediction_ready_0 =
  ~(~_io_fromBpu_prediction_ready_T & _io_fromBpu_prediction_ready_T_5[6])
  & (_io_fromBpu_prediction_ready_T_9
       ? _GEN_3
       : 7'(_io_fromBpu_prediction_ready_T_12 - _GEN_2)) < 7'h8 & ~(bpTrainStallCnt[3]);
```

Wolf shows constant 1 (no transitions), suggesting the complex condition is not being evaluated correctly or the dependent state variables are not updating properly.
