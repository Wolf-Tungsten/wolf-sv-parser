// Generated by CIRCT firtool-1.135.0

// Include register initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for register randomization.

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_
module MicroRas(
  input         clock,
  input         reset,
  input         io_stageCtrl_s1_fire,
  input         io_stageCtrl_s2_fire,
  input         io_stageCtrl_s3_fire,
  input  [48:0] io_specIn_startPc_addr,
  input  [4:0]  io_specIn_cfiPosition,
  input  [1:0]  io_specIn_attribute_rasAction,
  output [48:0] io_specOut_retTarget_addr,
  output        io_specOut_isCanUse,
  input         io_hasRedirect,
  input         io_hasOverride,
  input  [48:0] io_fullRetAddr_addr
);

  reg         s2_hasPush;
  reg         s2_hasPop;
  reg         s3_hasPush;
  reg         s3_hasPop;
  reg  [48:0] s2_retAddr_addr;
  reg  [48:0] s3_retAddr_addr;
  reg         isCanUse;
  reg  [48:0] topRetAddr_addr;
  reg         redirectDelay1;
  wire        specPush = io_specIn_attribute_rasAction == 2'h2;
  wire        specPop = io_specIn_attribute_rasAction == 2'h1;
  wire [49:0] _specPushAddr_T_3 =
    50'({45'(io_specIn_startPc_addr[48:4] + {44'h0, io_specIn_cfiPosition[4]}),
         io_specIn_cfiPosition[3:0],
         1'h0} + 50'h2);
  wire        _GEN = io_hasOverride | io_hasRedirect;
  wire        _GEN_0 = io_stageCtrl_s1_fire & specPush;
  wire        _GEN_1 = io_stageCtrl_s1_fire & specPop;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      s2_hasPush <= 1'h0;
      s2_hasPop <= 1'h0;
      s3_hasPush <= 1'h0;
      s3_hasPop <= 1'h0;
      s2_retAddr_addr <= 49'h0;
      s3_retAddr_addr <= 49'h0;
      isCanUse <= 1'h0;
      topRetAddr_addr <= 49'h0;
      redirectDelay1 <= 1'h0;
    end
    else begin
      s2_hasPush <=
        ~_GEN & (io_stageCtrl_s1_fire ? specPush : ~io_stageCtrl_s2_fire & s2_hasPush);
      s2_hasPop <=
        ~_GEN & (io_stageCtrl_s1_fire ? specPop : ~io_stageCtrl_s2_fire & s2_hasPop);
      s3_hasPush <=
        ~io_hasRedirect
        & (io_stageCtrl_s2_fire ? s2_hasPush : ~io_stageCtrl_s3_fire & s3_hasPush);
      s3_hasPop <=
        ~io_hasRedirect
        & (io_stageCtrl_s2_fire ? s2_hasPop : ~io_stageCtrl_s3_fire & s3_hasPop);
      if (_GEN_0)
        s2_retAddr_addr <= _specPushAddr_T_3[49:1];
      if (io_stageCtrl_s2_fire)
        s3_retAddr_addr <= s2_retAddr_addr;
      isCanUse <=
        ~io_hasRedirect
        & (io_hasOverride
             ? ~s3_hasPop
             : _GEN_0
               | (_GEN_1
                    ? (s2_hasPush ? s3_hasPush | ~s3_hasPop : ~s2_hasPop & s3_hasPush)
                    : io_stageCtrl_s1_fire
                        ? s2_hasPush
                          | (s2_hasPop
                               ? s3_hasPush
                               : ~s3_hasPop & (s3_hasPush | ~redirectDelay1))
                        : isCanUse));
      if (io_hasRedirect) begin
      end
      else if (io_hasOverride)
        topRetAddr_addr <=
          s3_hasPop ? 49'h0 : s3_hasPush ? s3_retAddr_addr : io_fullRetAddr_addr;
      else if (_GEN_0)
        topRetAddr_addr <= _specPushAddr_T_3[49:1];
      else if (_GEN_1) begin
        if (s2_hasPush)
          topRetAddr_addr <=
            s3_hasPush ? s3_retAddr_addr : s3_hasPop ? 49'h0 : io_fullRetAddr_addr;
        else if (s2_hasPop | ~s3_hasPush) begin
        end
        else
          topRetAddr_addr <= io_fullRetAddr_addr;
      end
      else if (io_stageCtrl_s1_fire) begin
        if (s2_hasPush)
          topRetAddr_addr <= s2_retAddr_addr;
        else if (s2_hasPop)
          topRetAddr_addr <= s3_hasPush ? io_fullRetAddr_addr : 49'h0;
        else if (s3_hasPop) begin
        end
        else
          topRetAddr_addr <=
            s3_hasPush ? s3_retAddr_addr : redirectDelay1 ? 49'h0 : io_fullRetAddr_addr;
      end
      redirectDelay1 <= io_hasRedirect;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:4];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        s2_hasPush = _RANDOM[3'h0][0];
        s2_hasPop = _RANDOM[3'h0][1];
        s3_hasPush = _RANDOM[3'h0][2];
        s3_hasPop = _RANDOM[3'h0][3];
        s2_retAddr_addr = {_RANDOM[3'h0][31:4], _RANDOM[3'h1][20:0]};
        s3_retAddr_addr = {_RANDOM[3'h1][31:21], _RANDOM[3'h2], _RANDOM[3'h3][5:0]};
        isCanUse = _RANDOM[3'h3][6];
        topRetAddr_addr = {_RANDOM[3'h3][31:7], _RANDOM[3'h4][23:0]};
        redirectDelay1 = _RANDOM[3'h4][24];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        s2_hasPush = 1'h0;
        s2_hasPop = 1'h0;
        s3_hasPush = 1'h0;
        s3_hasPop = 1'h0;
        s2_retAddr_addr = 49'h0;
        s3_retAddr_addr = 49'h0;
        isCanUse = 1'h0;
        topRetAddr_addr = 49'h0;
        redirectDelay1 = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_specOut_retTarget_addr = topRetAddr_addr;
  assign io_specOut_isCanUse = isCanUse;
endmodule

