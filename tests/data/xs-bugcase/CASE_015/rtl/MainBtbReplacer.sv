// Generated by CIRCT firtool-1.135.0

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module MainBtbReplacer(
  input        clock,
  input        reset,
  output [3:0] io_victim_wayMask,
  input        io_touch_0_valid,
  input  [7:0] io_touch_0_bits_setIdx,
  input  [3:0] io_touch_0_bits_wayMask,
  input        io_touch_1_valid,
  input  [7:0] io_touch_1_bits_setIdx,
  input  [3:0] io_touch_1_bits_wayMask
);

  wire [5:0] _stateBank_io_predictReadState;
  wire [5:0] _stateBank_io_trainReadState;
  wire [5:0] _trainStateGen_io_nextState;
  wire [1:0] _trainStateGen_io_victim;
  wire [5:0] _predictStateGen_io_nextState;
  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset
          & ~(~io_touch_1_valid
              | 3'({1'h0,
                    2'({1'h0, io_touch_1_bits_wayMask[0]}
                       + {1'h0, io_touch_1_bits_wayMask[1]})}
                   + {1'h0,
                      2'({1'h0, io_touch_1_bits_wayMask[2]}
                         + {1'h0, io_touch_1_bits_wayMask[3]})}) < 3'h2)) begin
        if (`ASSERT_VERBOSE_COND_)
          $fwrite(32'h80000002, "Assertion failed: victim wayMask should be at-most-one-hot\n");
        if (`STOP_COND_)
          xs_assert_v2(`__FILE__, `__LINE__);
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  LruStateGen predictStateGen (
    .io_state           (_stateBank_io_predictReadState),
    .io_touches_0_valid (io_touch_0_valid & io_touch_0_bits_wayMask[0]),
    .io_touches_1_valid (io_touch_0_valid & io_touch_0_bits_wayMask[1]),
    .io_touches_2_valid (io_touch_0_valid & io_touch_0_bits_wayMask[2]),
    .io_touches_3_valid (io_touch_0_valid & io_touch_0_bits_wayMask[3]),
    .io_nextState       (_predictStateGen_io_nextState)
  );
  LruStateGen_1 trainStateGen (
    .io_state           (_stateBank_io_trainReadState),
    .io_touches_0_valid (io_touch_1_valid),
    .io_touches_0_bits
      ({|(io_touch_1_bits_wayMask[3:2]),
        io_touch_1_bits_wayMask[3] | io_touch_1_bits_wayMask[1]}),
    .io_nextState       (_trainStateGen_io_nextState),
    .io_victim          (_trainStateGen_io_victim)
  );
  ReplacerState_4 stateBank (
    .clock                 (clock),
    .reset                 (reset),
    .io_predictReadSetIdx  (io_touch_0_bits_setIdx),
    .io_predictReadState   (_stateBank_io_predictReadState),
    .io_predictWriteValid  (io_touch_0_valid),
    .io_predictWriteSetIdx (io_touch_0_bits_setIdx),
    .io_predictWriteState
      (io_touch_0_valid ? _predictStateGen_io_nextState : _stateBank_io_predictReadState),
    .io_trainReadSetIdx    (io_touch_1_bits_setIdx),
    .io_trainReadState     (_stateBank_io_trainReadState),
    .io_trainWriteValid    (io_touch_1_valid),
    .io_trainWriteSetIdx   (io_touch_1_bits_setIdx),
    .io_trainWriteState
      (io_touch_1_valid ? _trainStateGen_io_nextState : _stateBank_io_trainReadState)
  );
  assign io_victim_wayMask = 4'h1 << _trainStateGen_io_victim;
endmodule

