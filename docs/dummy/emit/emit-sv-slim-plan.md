# Emit 流程精简计划（降低复杂度，保持输出等价）

## 说明
- 本文关注 **emit 实现流程与代码结构的精简**，不是精简 SV 输出格式。
- 输出语义应保持等价，不引入新的 IR 变换或优化。

## 目标
- 缩短 emit 关键路径，降低分支与重复逻辑。
- 让 emit 流程更线性、可预测、可追踪（便于排查问题）。
- 在不改变输出语义的前提下提升可读性与可维护性。

## 非目标
- 不改动 SV 输出风格（除非为去除重复逻辑导致的等价重排）。
- 不引入新的优化/变换（常量折叠、逻辑重写、结构重排等）。
- 不改变 GRH IR 的结构或语义。

## 约束与定义
- “流程精简”指：
  - 减少 emit 中的重复遍历、重复分支与重复的表达式/语句生成。
  - 统一同类节点的处理方式，降低特例数量。
  - 将“收集/组织数据”和“渲染输出”分离，职责清晰。
- 输出必须保持语义等价；不新增常量 expand 或其他结构性变换。

## 现状调研清单
- 读取 `src/emit.cpp` 与 `include/emit.hpp`，梳理：
  - 入口函数与主要阶段（声明、实例、assign、always 等）。
  - 表达式生成与语句生成的分工关系。
  - 同一 IR 节点在多个阶段被重复处理的路径。
  - 诊断/日志/统计在流程中的注入点。
- 评估 CLI 与 emit 配置结构是否为流程改造提供扩展点。

## 精简策略（流程级）
### 1) 统一流程形态
- 采用固定两阶段：**收集(Plan)** → **渲染(Render)**。
- 收集阶段只遍历 IR 一次（或有限次数），整理出统一的 EmitPlan：
  - 端口/声明/赋值/时序块/实例的结构化列表。
- 渲染阶段只按稳定顺序输出，不再触碰 IR 结构。

### 2) 合并重复逻辑
- 将表达式生成收敛到少量核心函数：
  - `EmitExpr` 只负责表达式，`EmitStmt` 只负责语句。
- 对同类节点（算术、比较、选择、拼接/切片）统一处理路径。
- 对寄存器/存储器/实例的生成逻辑统一入口，减少散落的特例。

### 3) 明确职责边界
- 结构收集与输出渲染明确分层，避免“边遍历边输出”。
- 缓存/索引/去重逻辑集中在收集阶段，不在渲染阶段重复判断。
- 诊断输出跟随阶段职责（收集时查错，渲染时仅输出）。

### 4) 稳定顺序与可追踪性
- 输出顺序固定且可预测（例如：端口 → 声明 → assign → always → 实例）。
- 为关键节点保留最少的结构性注释（可开关），便于 IR 对照。

## 实施步骤（细化）
1. **流程梳理**
   - 绘制 emit 调用路径与阶段分布。
   - 标注重复遍历与重复输出的热点区域。
2. **引入 EmitPlan**
   - 定义收集阶段的数据结构（端口/声明/赋值/时序/实例）。
   - 只在该阶段访问 IR，生成规范化列表。
3. **重构表达式/语句生成**
   - 统一 `EmitExpr` / `EmitStmt` 的入口与返回类型。
   - 清理重复代码与特例分支。
4. **渲染阶段重写**
   - 渲染阶段仅消费 EmitPlan，不再访问 IR。
   - 输出顺序固定，渲染逻辑保持极简。
5. **逐步迁移**
   - 先在功能最稳定的模块落地（如组合逻辑与实例）。
   - 分阶段替换原路径，确保可回滚。
6. **清理与文档**
   - 删除不再使用的辅助函数与旧路径。
   - 更新 `docs/emit/` 说明 emit 流程结构与职责划分。

## 验证与测试计划
- 现有测试：`tests/emit/test_emit_sv.cpp` 必须通过。
- 回归验证：
  - 关键 fixture 的输出与旧版本保持语义等价。
  - 对比输出差异，允许仅有等价重排或注释变化。
- 若可行：增加 “EmitPlan 单测” 或轻量级结构断言。

## 风险与应对
- **风险**：阶段分离导致输出顺序/细节改变。
  - **应对**：固定渲染顺序，并对输出做差异比对。
- **风险**：重复逻辑合并引入行为回归。
  - **应对**：逐步迁移、逐模块验证，保留回退点。

## 验收标准
- emit 入口流程清晰且可描述为“两阶段”。
- IR 遍历次数降低，重复分支与重复代码显著减少。
- 现有 emit 测试全通过，关键用例输出语义等价。
