DUT=097 与 DUT=098 修复报告
-------------------------

### 问题概述
- DUT=097：`make run_hdlbits_test DUT=097` 在 elaboration 阶段报 `Expected mux structure to derive reset value`，原因是顺序块被判定有复位，但 `in_last` 的数据路径并未依赖复位，提取复位分支失败后仍强行要求 mux。
- DUT=098：双沿寄存器同名写入被多次折叠，导致 “Duplicated operation symbol”/“Register operands not ready” 等异常，同时输出行为错误。
- 伴随改动引入的回归：`ctest` 中 `elaborate-rhs-converter` 触发 array slice 断言，因对解包数组的索引进行了不当的常量折叠。

### 解决方案
- 复位推导放宽：当数据值与复位信号无依赖时，不再强制提取复位分支，直接将寄存器状态机降级为无复位版本并清除 `rstPolarity` 属性，避免 NYI（`SeqAlwaysConverter::finalizeRegisterWrites`）。
- 多驱动寄存器拆分：
  - 在 memo 阶段对同名寄存器按驱动块复制条目并标记 `multiDriver`。
  - 顺序 finalize 时为每个驱动片段创建独立寄存器，并将各片段汇总到 `WriteBackMemo` 的多驱动桶里再统一 concat 回目标值，防止数据/操作重复绑定。
  - 名字生成和 zero/one 常量生成中加入 converter 实例 ID，避免跨块重复符号。
- Array slice 回归修复：只有在 selector 真为参数/枚举等常量时才提前静态切片；解包数组的动态索引不再做范围平移，保留 `kSliceArray` 语义以满足测试预期。

### 影响与验证
- HDLBits：`make run_hdlbits_test DUT=097`、`make run_hdlbits_test DUT=098` 通过，行为与参考仿真一致。
- 回归测试：`ctest --test-dir build --output-on-failure` 全部通过，`elaborate-rhs-converter` 中的 array slice 断言恢复。

### 注意事项
- 多驱动寄存器仅在 memo 阶段标记并延迟创建 stateOp，后续处理需使用 `target->value`（共享视图）而非 `stateOp`。
- 对解包数组的索引不要尝试常量平移，保持动态 slice 以避免下游检查失败。
