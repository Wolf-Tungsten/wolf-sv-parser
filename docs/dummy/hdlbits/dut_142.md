DUT=142 混合赋值的顺序语义修正
-------------------------------

- 问题：`make run_hdlbits_test DUT=142` 仿真失败，测试期望在 `state=1, count=2, count1=2` 时 `z=0`，实际 `z=1`，计数器在进入 B 状态的当拍就开始累加。
- 根因：顺序 always 同时包含非阻塞（`state <= next`）和阻塞计数更新，shadow 合并时把两类赋值混在一套缓存里，`if (state==B)` 的使能被污染成基于 next 的值（`s|state`），导致进入 B 的首拍也使能计数。
- 方案：为阻塞与非阻塞赋值分别维护 shadow 切片；RHS 读取只看阻塞切片以保持块内执行顺序，flush 时再将非阻塞切片叠加生成最终写回。增加独立缓存/dirty 标记，避免非阻塞写被提前读到，同时保留原有融合逻辑。可用 `WOLF_DEBUG_SHADOW_WRITE` 环境变量查看赋值类型。
- 结果：`make run_hdlbits_test DUT=142` 通过，仍只保留原题的阻塞赋值风格警告。
