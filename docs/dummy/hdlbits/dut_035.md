DUT=035 casez 通配字面量丢失有效位
------------------------------------

- 问题：`make run_hdlbits_test DUT=035` 仿真期望 `in=0x1` 输出 `pos=0`，实际得到 `1`，首个 casez 分支未命中。
- 根因：通配比较用的常量统一以 16 进制字符串输出，即便包含 z/x。`8'bzzzzzzz1` 被串化成 `8'hzZ`，低位的 `1` 丢失，生成的 XOR/AND/eq0 逻辑永远不匹配该分支。
- 方案：`formatConstantLiteral` 若检测到未知位，改用二进制基数输出，保持每一位的 z/x 与有效位不被合并。
- 验证：重新编译后 `make run_hdlbits_test DUT=035` 通过，仿真输出 `[TB] dut_035 passed: casez LSB encoder behavior verified`。***
