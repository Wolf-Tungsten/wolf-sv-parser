# XS wave diff 20260216_221813

Written: 2026-02-16 22:27:16 CST
Last updated: 2026-02-17 (corrected misleading conclusions)

---

## Executive Summary

**Root Cause Location:** `frontend.inner_ftq` (Ftq.sv), NOT `inner_bpu`

**Earliest Divergent Signal:** `io_fromBpu_prediction_ready` (output from FTQ, input to BPU)
- **Ref:** Transitions to 0 at t=1154
- **Wolf:** Remains constant 1 (no events in t=[1100, 1200])

**Divergence Propagation Chain:**
```
inner_ftq.io_fromBpu_prediction_ready (t=1154, ref=0, wolf=1)
  → inner_bpu.io_toFtq_prediction_ready
    → inner_bpu.s1_fire (= s1_valid & io_toFtq_prediction_ready)
      → inner_bpu.abtb_io_stageCtrl_s0_fire_probe
        → [cascades to all predictor submodules: abtb, tage, ittage, mbtb, etc.]
          → [629 signals diverge simultaneously at t=1154]
            → LogPerfEndpoint counters (symptomatic, downstream)
```

**Why CASE_014 (Bpu bugcase) Cannot Reproduce:**
- CASE_014 tests `inner_bpu` in isolation
- The bug originates in `inner_ftq`, upstream of `inner_bpu`
- Even a correctly-implemented `inner_bpu` will show divergence when driven by incorrect FTQ inputs

**Recommended Next Steps:**
1. Create CASE_016 targeting `inner_ftq` specifically
2. Extract FTQ boundary inputs from FST to create trace-replay stimulus
3. Focus debugging on the logic generating `io_fromBpu_prediction_ready` in Ftq.sv

---

## Earliest waveform divergence (all signals)
Command:
```
python3 tools/fst_diff_tool.py --fst-a build/logs/xs/xs_ref_20260215_171313.fst --fst-b build/logs/xs/xs_wolf_20260215_171313.fst --allow-all-signals --max-diffs 1 --format table
```

Tool summary:
- ROI t=[0, 16607]
- common=930301, compared=930301

Earliest diff:
- Signal: `TOP.SimTop.logEndpoint.WriteBuffer_abtbBank0_port0_usefulNSamples [63:0]`
- diverge_time: 1156
- value_a: 0000000000000000000000000000000000000000000000000000000111100010
- value_b: 0000000000000000000000000000000000000000000000000000000111100001
- end_value_a: 0000000000000000000000000000000000000000000000000001111111100001
- end_value_b: 0000000000000000000000000000000000000000000000000001111101001010

## Minimal producer module for earliest diff signal
Hierarchy breakdown:
- TOP
  - SimTop
    - logEndpoint (instance of `LogPerfEndpoint`)
      - WriteBuffer_abtbBank0_port0_usefulNSamples (local reg)

Evidence:
- `SimTop` instantiates `LogPerfEndpoint` as `logEndpoint` in `build/xs/rtl/rtl/SimTop.sv` (see the `LogPerfEndpoint logEndpoint (` block).
- `WriteBuffer_abtbBank0_port0_usefulNSamples` is declared as a local `reg [63:0]` inside `build/xs/rtl/rtl/LogPerfEndpoint.sv`.
- The same file updates the reg in the `LogPerfEndpoint` sequential logic (e.g. the `enable_bore_15` block increments the counter), so the signal is generated entirely within `LogPerfEndpoint` and does not originate from any submodule below it.

Conclusion:
- `LogPerfEndpoint` is a **symptomatic module**, not the root cause. It merely counts events from upstream BPU signals.
- The earliest divergent signal it produces (`WriteBuffer_abtbBank0_port0_usefulNSamples`) is a local counter incremented by `enable_bore_15` and other probe signals originating from `inner_bpu`.
- The true root cause lies upstream in the BPU/FTQ pipeline, not in LogPerfEndpoint itself.

## LogPerfEndpoint input consistency check
Command (all LogPerfEndpoint input ports, derived from the module header and mapped to `TOP.SimTop.logEndpoint.*`):
```
python3 tools/fst_diff_tool.py --fst-a build/logs/xs/xs_ref_20260215_171313.fst --fst-b build/logs/xs/xs_wolf_20260215_171313.fst --signals-file /tmp/logendpoint_inputs.signals --max-diffs 1 --t1 1156 --format table
```
Note: `/tmp/logendpoint_inputs.signals` was generated by parsing `build/xs/rtl/rtl/LogPerfEndpoint.sv` for input ports and intersecting with the FST signal list filtered by `TOP.SimTop.logEndpoint.*`.

Result:
- Inputs are **not** identical. The earliest input divergence is already present before the `WriteBuffer_abtbBank0_port0_usefulNSamples` mismatch.
- Earliest input diff (ROI t=[0, 1156]):
  - Signal: `TOP.SimTop.logEndpoint.enable_bore_102`
  - diverge_time: 1154
  - value_a: 1
  - value_b: 0

Additional scan (full ROI) shows more input mismatches later, e.g. `perfCnt_bore_*` and `perfOut_bore` diverging at t=1430, so the input streams are not fully aligned across ref/wolf for this instance.

Earlier-than-1154 check:
```
python3 tools/fst_diff_tool.py --fst-a build/logs/xs/xs_ref_20260215_171313.fst --fst-b build/logs/xs/xs_wolf_20260215_171313.fst --signals-file /tmp/logendpoint_inputs.signals --max-diffs 1 --t1 1153 --format jsonl --no-meta
```
Result: `{"result":"no_diff"}` (no input diffs before t=1154).

Reset window (both ref and wolf):
```
python3 tools/fst_roi/fst_roi.py --fst build/logs/xs/xs_ref_20260215_171313.fst --signal TOP.SimTop.logEndpoint.reset --t0 0 --t1 2000 --include-initial --max-events 10 --format table
python3 tools/fst_roi/fst_roi.py --fst build/logs/xs/xs_wolf_20260215_171313.fst --signal TOP.SimTop.logEndpoint.reset --t0 0 --t1 2000 --include-initial --max-events 10 --format table
```
Reset deasserts at t=100 in both runs, so the earliest input divergence at t=1154 occurs well after reset and is not attributable to random initialization.

All input divergences at t=1154 (LogPerfEndpoint inputs, 51 signals):
```
TOP.SimTop.logEndpoint.enable_bore_102
TOP.SimTop.logEndpoint.enable_bore_103
TOP.SimTop.logEndpoint.enable_bore_110
TOP.SimTop.logEndpoint.enable_bore_111
TOP.SimTop.logEndpoint.enable_bore_120
TOP.SimTop.logEndpoint.enable_bore_122
TOP.SimTop.logEndpoint.enable_bore_124
TOP.SimTop.logEndpoint.enable_bore_126
TOP.SimTop.logEndpoint.enable_bore_128
TOP.SimTop.logEndpoint.enable_bore_130
TOP.SimTop.logEndpoint.enable_bore_132
TOP.SimTop.logEndpoint.enable_bore_142
TOP.SimTop.logEndpoint.enable_bore_144
TOP.SimTop.logEndpoint.enable_bore_15
TOP.SimTop.logEndpoint.enable_bore_19
TOP.SimTop.logEndpoint.enable_bore_20
TOP.SimTop.logEndpoint.enable_bore_21
TOP.SimTop.logEndpoint.enable_bore_22
TOP.SimTop.logEndpoint.enable_bore_36
TOP.SimTop.logEndpoint.enable_bore_37
TOP.SimTop.logEndpoint.enable_bore_38
TOP.SimTop.logEndpoint.enable_bore_39
TOP.SimTop.logEndpoint.enable_bore_54
TOP.SimTop.logEndpoint.enable_bore_55
TOP.SimTop.logEndpoint.enable_bore_62
TOP.SimTop.logEndpoint.enable_bore_63
TOP.SimTop.logEndpoint.enable_bore_70
TOP.SimTop.logEndpoint.enable_bore_71
TOP.SimTop.logEndpoint.enable_bore_78
TOP.SimTop.logEndpoint.enable_bore_79
TOP.SimTop.logEndpoint.enable_bore_86
TOP.SimTop.logEndpoint.enable_bore_87
TOP.SimTop.logEndpoint.enable_bore_94
TOP.SimTop.logEndpoint.enable_bore_95
TOP.SimTop.logEndpoint.perfCnt_bore_1192
TOP.SimTop.logEndpoint.perfCnt_bore_1202
TOP.SimTop.logEndpoint.perfCnt_bore_1208
TOP.SimTop.logEndpoint.perfCnt_bore_160
TOP.SimTop.logEndpoint.perfCnt_bore_177
TOP.SimTop.logEndpoint.perfCnt_bore_212
TOP.SimTop.logEndpoint.perfCnt_bore_213
TOP.SimTop.logEndpoint.perfCnt_bore_215
TOP.SimTop.logEndpoint.perfCnt_bore_470
TOP.SimTop.logEndpoint.perfCnt_bore_514
TOP.SimTop.logEndpoint.perfCnt_bore_558
TOP.SimTop.logEndpoint.perfCnt_bore_602
TOP.SimTop.logEndpoint.perfCnt_bore_646
TOP.SimTop.logEndpoint.perfCnt_bore_690
TOP.SimTop.logEndpoint.perfCnt_bore_734
TOP.SimTop.logEndpoint.perfCnt_bore_778
TOP.SimTop.logEndpoint.perfCnt_bore_905
```

Upstream sources (from `SimTop.sv` LogPerfEndpoint port map):
```
enable_bore_102 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_6.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_103 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_6.tage_entry_write_buffer_bank0.io_read_1_ready_probe
enable_bore_110 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_7.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_111 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_7.tage_entry_write_buffer_bank0.io_read_1_ready_probe
enable_bore_120 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ittage.tables_0.ittage_write_buffer_bank0.io_read_0_ready_probe
enable_bore_122 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ittage.tables_1.ittage_write_buffer_bank0.io_read_0_ready_probe
enable_bore_124 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ittage.tables_2.ittage_write_buffer_bank0.io_read_0_ready_probe
enable_bore_126 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ittage.tables_3.ittage_write_buffer_bank0.io_read_0_ready_probe
enable_bore_128 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ittage.tables_4.ittage_write_buffer_bank0.io_read_0_ready_probe
enable_bore_130 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.sc.pathTable_0.writeBuffer_0.io_read_0_ready_probe
enable_bore_132 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.sc.pathTable_1.writeBuffer_0.io_read_0_ready_probe
enable_bore_142 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.sc.biasTable.writeBuffer_0.io_read_0_ready_probe
enable_bore_144 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu._GEN_1
enable_bore_15 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.abtb.banks_0.writeBuffer.io_read_0_ready_probe
enable_bore_19 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_0.internalBanks_0.entryWriteBuffer.io_read_0_ready_probe
enable_bore_20 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_0.internalBanks_0.entryWriteBuffer.io_read_1_ready_probe
enable_bore_21 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_0.internalBanks_0.entryWriteBuffer.io_read_2_ready_probe
enable_bore_22 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_0.internalBanks_0.entryWriteBuffer.io_read_3_ready_probe
enable_bore_36 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_1.internalBanks_0.entryWriteBuffer.io_read_0_ready_probe
enable_bore_37 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_1.internalBanks_0.entryWriteBuffer.io_read_1_ready_probe
enable_bore_38 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_1.internalBanks_0.entryWriteBuffer.io_read_2_ready_probe
enable_bore_39 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.mbtb.alignBanks_1.internalBanks_0.entryWriteBuffer.io_read_3_ready_probe
enable_bore_54 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_0.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_55 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_0.tage_entry_write_buffer_bank0.io_read_1_ready_probe
enable_bore_62 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_1.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_63 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_1.tage_entry_write_buffer_bank0.io_read_1_ready_probe
enable_bore_70 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_2.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_71 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_2.tage_entry_write_buffer_bank0.io_read_1_ready_probe
enable_bore_78 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_3.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_79 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_3.tage_entry_write_buffer_bank0.io_read_1_ready_probe
enable_bore_86 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_4.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_87 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_4.tage_entry_write_buffer_bank0.io_read_1_ready_probe
enable_bore_94 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_5.tage_entry_write_buffer_bank0.io_read_0_ready_probe
enable_bore_95 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_5.tage_entry_write_buffer_bank0.io_read_1_ready_probe
perfCnt_bore_1192 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.sc._bwTable_1_io_req_valid_T_probe
perfCnt_bore_1202 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu._GEN_2
perfCnt_bore_1208 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu._GEN_9
perfCnt_bore_160 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ubtb._GEN_6
perfCnt_bore_177 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.abtb.banks_0._GEN
perfCnt_bore_212 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.abtb_io_stageCtrl_s0_fire_probe
perfCnt_bore_213 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.abtb.s2_fire_probe
perfCnt_bore_215 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.abtb._GEN_304
perfCnt_bore_470 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_0_io_predictReadReq_valid_probe
perfCnt_bore_514 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_1_io_predictReadReq_valid_probe
perfCnt_bore_558 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_2_io_predictReadReq_valid_probe
perfCnt_bore_602 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_3_io_predictReadReq_valid_probe
perfCnt_bore_646 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_4_io_predictReadReq_valid_probe
perfCnt_bore_690 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_5_io_predictReadReq_valid_probe
perfCnt_bore_734 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_6_io_predictReadReq_valid_probe
perfCnt_bore_778 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_7_io_predictReadReq_valid_probe
perfCnt_bore_905 <= SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ittage.s1_fire_probe
```

Analysis (cause of divergence):
- All 1154-time divergences originate from `SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu` (TAGE/ITTAGE/SC/ABTB/MBTB/UBTB). These are predictor read-ready probes and predict-read request valid probes, plus a few internal probe wires (`_GEN_*`), not LogPerfEndpoint-generated signals.
- The breadth of simultaneous differences across multiple BPU tables at t=1154 indicates the frontend prediction pipeline has already diverged between ref and wolf by that time (different prediction/read activity and stage fires). LogPerfEndpoint simply counts these events, so it is downstream/symptomatic, not the source of divergence.
- Since reset deasserts at t=100 in both runs, this divergence is not explainable by random initialization. Root-cause investigation should move upstream into the frontend BPU (e.g., fetch/BTB/TAGE update paths) around t≈1154 to find the first control/state discrepancy.

## Earlier-than-1154 scan inside inner_bpu (post-reset, ignore X/Z)
Method:
- Compared all `TOP.SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.*` signals (93,304 signals).
- Time window t=[100, 1154] (reset deasserts at t=100).
- Ignored X/Z differences to avoid random-init noise.
- Used a custom scan (based on `fst_diff_tool._collect_events`) that checks for the earliest time any signal’s value differs, not only those that differ at t1.

Result:
- Earliest divergence time inside `inner_bpu` is still **t=1154**; no signal differs in t=[100, 1153] under the ignore-X/Z rule.
- At t=1154, **629** `inner_bpu` signals diverge simultaneously.

Breakdown by `inner_bpu` sub-block (count of signals diverging at t=1154):
- `tage`: 251
- `mbtb`: 108
- `phr`: 98
- `ittage`: 73
- `abtb`: 43
- `sc`: 41
- `commonHR`: 5
- `ubtb`: 3
- `fallThrough`: 2
- `uras`: 1
- `utage`: 1
- top-level `inner_bpu` flags (`io_toFtq_prediction_ready`, `s1_fire`, `abtb_io_stageCtrl_s0_fire_probe`): 3

Representative earliest-divergence signals at t=1154:
- `TOP.SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.io_toFtq_prediction_ready`
- `TOP.SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.s1_fire`
- `TOP.SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.abtb.banks_0.io_readReq_valid`
- `TOP.SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.ittage.tables_0.io_req_valid`
- `TOP.SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.tage.tables_6.io_predictReadReq_valid`

Interpretation:
- The earliest observable divergence inside `inner_bpu` coincides with the 1154-time LogPerfEndpoint input split, implying the divergence appears first in the frontend prediction pipeline at that time (not earlier) and then fans out across multiple predictor structures (TAGE/ITTAGE/MBTB/ABTB/SC/PHR).

## Input consistency verification for inner_bpu
To determine if the divergence originates inside `inner_bpu` or is driven by upstream inputs, we verified the boundary signals:

**Method:**
- Compared all 711 `inner_bpu` boundary signals (`io_*`) in t=[100, 1153].
- Command: `fst_diff_tool.py --signal "TOP.SimTop.cpu.l_soc.core_with_l2.core.frontend.inner_bpu.io_*" --t0 100 --t1 1153`

**Result:**
- **No diffs found** in t=[100, 1153]. All boundary signals are equivalent before t=1154.
- At t=1154, boundary signals start diverging, including:
  - `io_toFtq_prediction_ready` (ref=0, wolf=1)
  - `io_fromFtq_train_ready` (ref=0, wolf=1)
  - Various `io_fromFtq_*` control signals

**Conclusion:** `inner_bpu` primary boundary inputs (from FTQ) are equivalent in t=[100, 1153]. However, the divergence first appears at t=1154 in:
1. **Output:** `io_toFtq_prediction_ready` - generated by FTQ, consumed by BPU
2. **Internal control:** `abtb_io_stageCtrl_s0_fire_probe` - generated inside `inner_bpu` based on `s1_valid` and `s1_fire`

**Definitive conclusion:** The root cause is **upstream in `inner_ftq`**.
- `inner_bpu` is merely propagating the divergence from its input `io_toFtq_prediction_ready`
- The handshake logic itself (combinational AND gate for `s1_fire`) is correct
- The issue is that `inner_ftq` generates incorrect/different `io_fromBpu_prediction_ready` signal in wolf vs ref

---

## Root cause: upstream in inner_ftq
Tracing the earliest divergent signal `io_toFtq_prediction_ready`:

**Signal path:**
- `inner_bpu.io_toFtq_prediction_ready` (input to BPU)
- Driven by: `inner_ftq.io_fromBpu_prediction_ready` (output from FTQ)

**Verification:**
```
ref:  io_fromBpu_prediction_ready @ t=1154 = 0
wolf: io_fromBpu_prediction_ready @ t=1154 = 1 (unchanged from initial value)
```

Both signals show identical divergence pattern at t=1154.

**Key finding:**
- In wolf waveform, `io_fromBpu_prediction_ready` has **no events** in t=[1100, 1200], maintaining initial value of 1.
- In ref waveform, it transitions to 0 at t=1154.
- This indicates wolf-sv-parser may not be correctly modeling the `inner_ftq` logic that generates `io_fromBpu_prediction_ready`.

---

## Sub-module analysis
Analyzed key `inner_bpu` sub-modules to understand divergence propagation:

| Module | External Boundary Inputs | Internal Control Inputs | Output/Internal Status |
|--------|-------------------------|------------------------|------------------------|
| `ubtb` | 15 signals equivalent (clock, reset, enable, startPc, etc.) | `io_stageCtrl_s0_fire`, `io_stageCtrl_s1_fire` diverge at 1154 | `s1_fire`, internal state diverges |
| `phr` | 40 `io_s*` data inputs equivalent | `io_train_stageCtrl_s0_fire` diverges at 1154 | `hash`, `io_train_s1_valid` diverge |
| `abtb` | External inputs equivalent | `io_stageCtrl_s0_fire`, `io_stageCtrl_s1_fire` diverge at 1154 | Multiple signals diverge |
| `commonHR` | External inputs equivalent | `io_stageCtrl_s0_fire` diverges at 1154 | Multiple signals diverge |

**Key insight:**
- All submodules receive equivalent **external boundary inputs** (from outside `inner_bpu`)
- However, they receive divergent **internal control inputs** (`io_stageCtrl_*`) generated by `inner_bpu` top-level logic
- The `io_stageCtrl_*` signals are driven by `abtb_io_stageCtrl_s0_fire_probe`, which depends on `s1_fire` → `io_toFtq_prediction_ready` (from FTQ)
- **Conclusion:** Submodules are not independent divergence sources; they are downstream of the central control divergence

---

## Commonality + minimal reproduction target
Commonality across the 629 earliest-divergence `inner_bpu` signals (t=1154):
- Dominated by predictor table **read activity**: SRAM/array read enables and clocks (`RW0_en`, `ren`, `rckEn`, `rcg.*`) and read request valids (`io_r_req_valid`, `io_req_valid`, `io_predictReadReq_valid`).
- Many **write-buffer read-ready** probes (`io_read_0_ready`, `io_read_1_ready`, and probes) across TAGE/ITTAGE/MBTB/ABTB/SC banks.
- Several **stage-control fires** (`io_stageCtrl_s0_fire`, `io_stageCtrl_s1_fire`, `s0_fire`, `s1_fire`) and top-level readiness (`io_toFtq_prediction_ready`).

Why they differ:
- The earliest divergent signals at t=1154 are:
  1. **`io_toFtq_prediction_ready`** (input from FTQ to BPU) - driven by `inner_ftq.io_fromBpu_prediction_ready`
  2. **`s1_fire`** (internal to BPU) - combinational logic: `s1_valid & io_toFtq_prediction_ready`
  3. **`abtb_io_stageCtrl_s0_fire_probe`** (internal control) - depends on `s1_fire`, `s1_valid`, `s2_flush`, and reset-done flags
  
**Dependency chain:**
```
inner_ftq.io_fromBpu_prediction_ready 
  → inner_bpu.io_toFtq_prediction_ready
    → inner_bpu.s1_fire
      → inner_bpu.abtb_io_stageCtrl_s0_fire_probe
        → [all submodules: abtb, tage, ittage, mbtb, etc.]
```

- Once `io_toFtq_prediction_ready` differs (ref=0, wolf=1), `s1_fire` immediately diverges (ref=0, wolf=1).
- This causes `abtb_io_stageCtrl_s0_fire_probe` to diverge, which fans out to all predictor submodules.
- **All downstream predictor read requests and SRAM enables diverge in the same cycle (t=1154)**, explaining the large, simultaneous divergence set.

**Root cause location:** `inner_ftq` - specifically in the logic generating `io_fromBpu_prediction_ready`.
- In wolf: signal stays at constant 1 (no events in t=[1100, 1200])
- In ref: signal transitions to 0 at t=1154
- This suggests wolf-sv-parser is not correctly modeling the FTQ logic that computes `io_fromBpu_prediction_ready`.

Minimal module for reproduction:
- **Primary target:** `frontend.inner_ftq` (Ftq.sv)
  - Contains the logic generating `io_fromBpu_prediction_ready`
  - This is the earliest divergent signal in the dependency chain
  - Wolf shows constant 1 (no transitions); Ref shows transition to 0 at t=1154
  
- **Why CASE_014 (inner_bpu) cannot reproduce:**
  - CASE_014 tests `Bpu` module (inner_bpu)
  - The divergence originates upstream in `inner_ftq`, not in `inner_bpu`
  - Even if `inner_bpu` logic is correct, it will show divergence when driven by divergent FTQ inputs
  
- **Recommended approach:**
  - Create CASE_016 targeting `inner_ftq` specifically
  - Extract FTQ inputs from FST and replay to isolate the bug
  - Alternatively, create a combined `frontend` test case including both `inner_ftq` and `inner_bpu`
