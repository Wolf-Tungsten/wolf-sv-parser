# XS 波形差异诊断（2026-02-14 19:05:29）

## 摘要
- ref 跑到 cycle limit（5000）后停止；wolf 在 cycle 543 因 `TLToAXI4_1.sv:313` 断言失败中止。
- FST 时间范围只有 `t=[0,3]`，且关键内部信号无事件变化，无法用波形直接定位 543 周期的触发点。
- 进一步对比 wolf emit 与原始 RTL，发现 `TLToAXI4_1` 内部对 `_GEN[auto_in_a_bits_source]` 的**packed 数组降级逻辑错误**：
  1) 把 2D packed 常量 `_GEN` 展平时**元素顺序反了**。
  2) 在 `queue_arw_deq_q.io_enq_bits_id` 的取值里**漏乘以元素宽度（5）**。
- 结果是 **AXI ID 与计数器位选择不一致**，出现 `dec_1` 发生时 `count_1==0` 的非法情况，触发 `ToAXI4.scala:273` 断言（`TLToAXI4_1.sv:313`）。

## 日志证据
- ref：`build/logs/xs/xs_ref_20260214_190529.log:9-11` 显示达到 cycle limit（5000）。
- wolf：`build/logs/xs/xs_wolf_20260214_190529.log:8-12` 显示 `TLToAXI4_1.sv:313` 断言失败并在 cycle 543 中止。

## 波形结论（为何不能直接定位）
`fst_diff_tool` 元数据表明 ROI 只有 `t=[0,3]`，且关键内部信号（如 `tl2axi4_1.dec_1`/`count_1`/`wd___expr_20`）在 FST 中无变化记录。该波形无法反推出 543 周期的触发瞬间，因此需要转向 RTL/emit 静态对比。

## 关键 RTL/emit 证据
### 1) 原始 RTL：_GEN 为 32×5 的 packed 数组
- `_GEN` 定义：`build/xs/rtl/rtl/TLToAXI4_1.sv:162-194`
- `queue_arw_deq_q.io_enq_bits_id` 直接取 `_GEN[auto_in_a_bits_source]`：`build/xs/rtl/rtl/TLToAXI4_1.sv:645`
- 计数选择 `_a_sel_T = 32'h1 << _GEN[auto_in_a_bits_source]`：`build/xs/rtl/rtl/TLToAXI4_1.sv:255`

### 2) wolf emit：packed 数组展开与索引错误
- `_GEN` 被折叠为 `__constfold__0_0 = 160'h107b9ac5a928398a418820`：`build/xs/wolf/wolf_emit/wolf_emit.sv:492159`

**(a) _a_sel_T 的索引顺序反了**
- wolf emit：
  - `__expr_361 = auto_in_a_bits_source * 5`（正确乘宽）
  - `__expr_362 = __constfold__0_0[__expr_361 +: 5]`
  - `_a_sel_T = 32'd1 << __expr_362`
  - 见：`build/xs/wolf/wolf_emit/wolf_emit.sv:491744-491748`
- 但 `__constfold__0_0` 的 5-bit 元素顺序与原始 `_GEN` 反向，导致 `__expr_362` 映射错误。

**(b) queue_arw_deq_q 的 ID 取值漏乘以 5**
- wolf emit：`__expr_267 = __constfold__0_0[auto_in_a_bits_source +: 5]`（少了 `*5`）
- 见：`build/xs/wolf/wolf_emit/wolf_emit.sv:491616`
- 这会把 source=1 解释成取常量的 bit[1+:5]，完全不同于原始 `_GEN[1]`。

### 3) 具体示例（从 __constfold__0_0 计算）
以 `auto_in_a_bits_source = 1` 为例：
- 原始 `_GEN[1] = 0`
- wolf emit：
  - `__expr_267`（无 *5）= 16
  - `__expr_362`（有 *5 但顺序反）= 1

这说明：
- **ID（用于 AXI）被写成 16**，而
- **计数位选择被写成 1**，
两者不一致，必然导致 `dec_1` 与 `count_1` 脱节。

## 根因判断
wolf-sv-parser 在 convert/emit 过程中对 **packed 数组常量 (`wire [31:0][4:0]`) 的展开与索引**实现错误：
1) **元素顺序反转**（LSB/MSB 方向处理不一致）。
2) **对 `arr[idx]` 的取值漏掉 `idx * elem_width`**。

这直接破坏了 TLToAXI4_1 中 **source → AXI ID → counter** 的一致性，导致 `dec_1 & ~count_1` 成立，从而触发 `ToAXI4.scala:273` 断言（`TLToAXI4_1.sv:313`）。

## 建议修复方向
- 修复 packed 数组的降级规则：
  - `arr[idx]` 应展开为 `packed[idx*elem_width +: elem_width]`；
  - 确保 packed 数组在扁平化时**元素顺序与 SV 规范一致**。
- 增加单测覆盖：
  - 2D packed 常量 + 动态索引场景；
  - 验证 `_GEN[idx]` 与 emit 后的取值一致。
