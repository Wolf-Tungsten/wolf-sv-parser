# XS Waveform Diff Diagnosis (2026-02-13 19:00:24)

## Executive Summary
- Ref run reaches cycle limit while wolf aborts at cycle 0, so divergence happens at initialization.
- `tools/fst_diff_tool.py` shows earliest diffs at t=0; the first listed signal is `SimJTAG.random_bits` (explicit `$random` init in ref) which is uninitialized in wolf emit.
- Additional earliest diffs are in IOPMP tables (`entry_addr` / `entry_addrh` / `ctrl` paths), consistent with uninitialized memory/register state differences.
- Likely root cause: wolf emit drops declaration initializers (e.g., `logic [31:0] random_bits = $random;`) and does not preserve init semantics for certain sim-only constructs, causing immediate state mismatch.

## Log Evidence
- Ref reaches cycle limit: `build/logs/xs/xs_ref_20260213_190024.log:1-11`.
- Wolf aborts at cycle 0 with `MEFreeList.sv:2032` assertion: `build/logs/xs/xs_wolf_20260213_190024.log:1-18`.

## FST Evidence (fst_diff_tool)
Command:
```
python3 tools/fst_diff_tool.py \
  --fst-a build/logs/xs/xs_ref_20260213_190024.fst \
  --fst-b build/logs/xs/xs_wolf_20260213_190024.fst \
  --top 5 --format table
```
Earliest diffs (t=0) include:
- `TOP.SimTop.cpu.jtag.random_bits`
- `TOP.SimTop.cpu.l_simMMIO.iopmp.iopmp_checker.ctrl.io_mdcfg_j_indx`
- `TOP.SimTop.cpu.l_simMMIO.iopmp.iopmp_checker.entry_table.entry_addr.io_a_rdata`
- `TOP.SimTop.cpu.l_simMMIO.iopmp.iopmp_checker.entry_table.entry_addr.mem_ext.R1_data`
- `TOP.SimTop.cpu.l_simMMIO.iopmp.iopmp_checker.entry_table.entry_addrh.io_a_rdata`

## Reset Waveform Check
Using `fst_diff_tool.py` to compare reset signals between ref and wolf shows **no differences** in the reset waveforms for key nodes, so reset behavior matches ref and is not the divergence source:
- `TOP.reset` (no diff)
- `TOP.SimTop.cpu.reset` (no diff)
- `TOP.SimTop.cpu.l_soc.io_reset` (no diff)
- `TOP.SimTop.cpu.l_soc.core_with_l2.core.backend.inner_ctrlBlock.rename.intFreeList.reset` (no diff)
- `TOP.SimTop.cpu.jtag.r_reset` (no diff)

`fst_roi` snapshot around reset release shows identical timing in both runs:
- `intFreeList.reset`: `1` at t=0, deasserts to `0` at t=2 (ps timescale)
- other reset signals (`TOP.reset`, `cpu.reset`, `io_reset`, `jtag.r_reset`) stay `0` over t=[0,200000]

This suggests the assertion is not caused by a reset waveform mismatch between ref and wolf. The likely issue remains missing/altered initialization semantics after reset release or an evaluation mismatch in wolf emit.

Command example (wolf):
```
/usr/bin/python3 tools/fst_roi/fst_roi.py \
  --fst build/logs/xs/xs_wolf_20260213_190024.fst \
  --signals-file /tmp/xs_reset_signals.txt \
  --t0 0 --t1 200000 --format table --match-strip-width --strip-width
```

## Source vs Wolf Emit Comparison
### 1) SimJTAG random_bits initialization dropped
Ref (explicit declaration initializer):
- `tests/data/xiangshan/difftest/src/test/vsrc/common/SimJTAG.v:50-53`

Wolf emit declares `random_bits` but has no assignment/init:
- `build/xs/wolf/wolf_emit/wolf_emit.sv:59841-59900`

This explains the t=0 mismatch on `random_bits`.

### 2) IOPMP table reads differ at t=0
The diff signals are sourced from IOPMP tables:
- `build/xs/rtl/rtl/IopmpChecker.sv:148-183` (Ctrl + tables)
- `build/xs/rtl/rtl/MdcfgTable.sv:46-93` (mdcfg table)
- `build/xs/rtl/rtl/EntryTable.sv:46-144` (entry tables)

These tables are SRAM-backed and depend on initial state. With missing or altered init behavior in wolf emit, their read data can diverge immediately at t=0.

## Root Cause (Most Likely)
- Wolf emit does not preserve declaration-time initializers (e.g., `logic x = $random`) and may drop other sim-only init semantics.
- As a result, ref gets non-zero/random values while wolf defaults to zero or X, causing immediate divergence and downstream assertion failures.

## MEFreeList Assertion Analysis (random init impact)
Yes — incorrect random initialization or missing/partial initialization can trigger the following assertion:
```
distanceBetween(tailPtr, debugArchHeadPtr) +& PopCount(debugUniqPR) =/= size.U
```
In `MEFreeList.sv`, this shows up as `_GEN_45` comparing the sum to `9'hE0` (224). See:
- Assertion and formula: `build/xs/rtl/rtl/MEFreeList.sv:2013-2033`
- Reset initializes tail/head pointers and debug RAT state: `build/xs/rtl/rtl/MEFreeList.sv:2211-2449`
- debugArchRAT is sourced from `io_debug_rat_*`: `build/xs/rtl/rtl/MEFreeList.sv:6138-6155`

Why init problems trigger it:
- The assertion checks **partition completeness**: free-list length (`distanceBetween`) + number of **unique** physical registers mapped in the arch RAT (`PopCount(debugUniqPR)`) must equal total PRF size (224).
- With a **correct reset**, even if randomization is disabled, the invariant holds (e.g., `tailPtr=0xDF`, `debugArchHeadPtr=0`, `debugArchRAT_* = 0` gives 223 + 1 = 224).
- If **reset is not applied correctly** (e.g., ResetGen init semantics dropped or reset deasserts before internal state stabilizes), then tail/head pointers or `io_debug_rat_*` can be X/garbage. That breaks the count, and `_GEN_45` asserts immediately.
- If **random init is applied inconsistently** (some blocks randomized, others zeroed), the arch RAT entries can become invalid or inconsistent with the free list, also violating the invariant.

Practical implication for the current wolf run:
- The assertion at cycle 0 strongly suggests **state divergence at reset release**, not a functional execution bug. The likely culprits are missing init semantics (declaration initializers / `initial` blocks) and/or upstream debug RAT signals not being properly reset before MEFreeList checks the invariant.

## fst_roi Snapshot: Assertion Inputs (t=0 / t=2)
Using `tools/fst_roi/fst_roi.py` to capture assertion-related inputs at t=0 and t=2 shows **no differences** between ref and wolf:

Command example (wolf):
```
/usr/bin/python3 tools/fst_roi/fst_roi.py \
  --fst build/logs/xs/xs_wolf_20260213_190024.fst \
  --signals-file /tmp/xs_roi_signals.txt \
  --t0 2 --t1 2 --format table --match-strip-width --strip-width
```

Observed values (ref and wolf are identical at t=0 and t=2):
- `tailPtr_flag = 0`, `tailPtr_value = 0xDF` (binary `11011111`)
- `debugArchHeadPtr_flag = 0`, `debugArchHeadPtr_value = 0x00`
- `debugArchRAT_0..31 = 0x00`
- `io_debug_rat_0..31 = 0x00`

These snapshots imply `distanceBetween(tailPtr, debugArchHeadPtr)` should be 223 and `PopCount(debugUniqPR)` should be 1, so the sum equals 224 and the assertion should not fire **if the formula is evaluated with these exact values**.

## Derived updateCond (from visible signals)
In wolf_emit, the kDPICall update condition is:
- `updateCond = __expr_6 = _GEN_45 & ~reset`
- `_GEN_45 = (distanceBetween(tailPtr, debugArchHeadPtr) + PopCount(debugUniqPR) != 224)`

Using the FST-visible values at t=0 and t=2:
- `distanceBetween = 0xDF - 0x00 = 223` (flags equal)
- `PopCount(debugUniqPR) = 1` (only debugArchRAT_0 is unique when all 32 RAT entries are 0)
- Sum = 224 ⇒ `_GEN_45 = 0`
- t=0: `~reset = 0` ⇒ `updateCond = 0`
- t=2: `~reset = 1` but `_GEN_45 = 0` ⇒ `updateCond = 0`

Conclusion: **based on the visible FST signals, updateCond should be false**, which conflicts with the observed assertion in wolf. This strengthens the hypothesis that either (a) the assertion expression is evaluated differently in wolf_emit (width/sign/ordering), or (b) there is a transient/X state not captured in the current wave dump. To resolve, `_GEN_45` / `__expr_6` must be dumped or explicitly exported.

## Assertion Variable Consistency (tailPtr / debugArchHeadPtr / debugUniqPR)
The assertion requires these three components to be mutually consistent at the time it fires:
1) `distanceBetween(tailPtr, debugArchHeadPtr)` — free-list count implied by tail/debug head pointers.
2) `PopCount(debugUniqPR)` — number of unique physical registers referenced by the arch RAT snapshot.
3) `size.U (224)` — total physical register count.

From RTL behavior:
- `tailPtr_*` and `debugArchHeadPtr_*` are explicitly reset in the synchronous reset block (`build/xs/rtl/rtl/MEFreeList.sv:2211-2449`).
- `debugArchRAT_*` is latched from `io_debug_rat_*` every cycle and then used to form `debugUniqPR` (`build/xs/rtl/rtl/MEFreeList.sv:6138-6155`).

What “inconsistency” looks like:
- If tail/head pointers are in reset-consistent values but `io_debug_rat_*` is X/garbage, then `debugUniqPR` becomes invalid and the sum no longer equals 224.
- If init is partially dropped (some blocks randomized, others zeroed), `debugArchRAT_*` can contain duplicates or out-of-range values, reducing `PopCount(debugUniqPR)` and violating the invariant even if pointers look sane.

Wave evidence so far:
- Reset signals match between ref and wolf (see “Reset Waveform Check”), so a reset waveform mismatch is unlikely.
- `tailPtr` / `debugArchHeadPtr` / `debugArchRAT` / `io_debug_rat` values are identical between ref and wolf at t=0 and t=2 (see “fst_roi Snapshot: Assertion Inputs”).
- Earliest diffs are in sim-only/randomized values (SimJTAG random_bits, IOPMP tables), consistent with post-reset initialization divergence.

Conclusion:
- The immediate assertion in wolf is **not explained by the observed input snapshots**; it points to either:
  1) a mismatch in how the wolf-emitted SV computes the assertion expression (width/sign/ordering), or
  2) additional internal state that is not dumped (e.g., transient X propagation) before the first observed snapshot.

## Suggested Fix Directions
1) Preserve declaration initializers in wolf emit (e.g., `logic [31:0] random_bits = $random;`).
2) Ensure sim-only init semantics for tables/regs are preserved or explicitly zeroed for both ref and wolf.
3) Re-run `fst_diff_tool.py` after fixes to confirm t=0 diffs are gone and wolf runs beyond cycle 0.
